# LeetCode Practice Study Plan

## üéØ Top Priority Categories

These are the ones you must master first ‚Äî they appear in ~80% of interviews and form the foundation.

### Array (Very High Priority)

**Why:** Most problems are array-based; basic building block.

**Examples** to learn: Two Sum, Move Zeroes, Remove Duplicates (sorted), Rotate Array, Merge Sorted Array, Intersection.

**Target:** 40‚Äì60 problems (easy ‚Üí medium)







### String (very high)

**Why:** Many interview questions & test cases use strings.

**Examples:** Reverse String, Valid Palindrome, Longest Common Prefix, Implement strStr, Anagrams, First Unique Character.

**Target:** 25‚Äì40 problems (easy ‚Üí medium)








### Hash Table (very high)

**Why:** Frequency counting, lookup, grouping ‚Äî essential for real problems.

**Examples:** Group Anagrams, Top K Frequent Elements, Valid Anagram, Two Sum (hash), Majority Element.

**Target:** 25‚Äì30 problems






### Two Pointers & Sliding Window (very high)

**Why:** Many optimized solutions use these patterns (subarrays, substrings, pairs).

**Examples:** (Two Pointers): Container With Most Water, 3Sum (learn extension), Sort Colors.

**Examples:** (Sliding Window): Longest Substring Without Repeating, Minimum Window Substring, Max sum subarray of size K.

**Target:** 30‚Äì40 problems (mix fixed-size & variable-size windows)






### Sorting & Binary Search (high)

**Why:** Sorting is a pre-step; binary search used in search problems & ‚Äúsearch on answer‚Äù.

**Examples:** Search in Rotated Sorted Array, Median of Two Sorted Arrays (advanced), Kth largest.

**Target:** 20‚Äì30 problems


Cycle fdetection




## Mid priority categories (next, after basics)






These are common in interviews and useful to know after you handle the top group.

### Stack / Queue

**Examples:** Valid Parentheses, Min Stack, Evaluate RPN, Sliding window monotonic queue.

**Target:**  10‚Äì20 problems




### Linked List

**Examples:** Reverse Linked List, Merge Two Sorted Lists, Detect Cycle, Remove N-th from end.

**Target:**  15 problems





### Tree (Binary Tree) & BFS / DFS

**Why:** Essential for many product interviews (medium to hard).

**Examples:** Binary Tree Level Order, Max Depth, Validate BST, Lowest Common Ancestor, Tree traversals.

**Target:** 30‚Äì40 problems







### Heap (Priority Queue)

**Examples:** Merge K Sorted Lists, Top K Frequent Elements, Sliding window median (harder).

**Target:**  8‚Äì12 problems






### Prefix Sum / Counting

**Why:** Useful for range sum queries, quick counts.

**Examples:** Subarray sum equals K, Moving Average from Data Stream (concepts).

**Target:** 10‚Äì15 problems







## Advanced / lower priority (learn later or when targeting FAANG SWE rather than SDET)

These are important for deep SWE roles or specialized interviews. For SDET roles you can leave many of these for later.






## Dynamic Programming (important but conceptually heavier) 

 start after you‚Äôve done many medium problems. Target core DP: Climbing Stairs, House Robber, Coin Change, Longest Increasing Subsequence. (30‚Äì50 problems over time)
 
 
 
 
 

## Graph (shortest path, SCC, topological sort) 

learn basics BFS/DFS first, then graph problems.





## Trie, Segment Tree, Binary Indexed Tree, Suffix Array, Rolling Hash, Line Sweep, Advanced Graph Algorithms, Bitmask DP, Combinatorics, etc. ‚Äî 

learn only if you aim for advanced SWE roles.





## Concurrency, Design, System topics 

more for senior roles/interviews.



